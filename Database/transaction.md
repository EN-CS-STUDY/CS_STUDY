#### 작성자: 신지훈

## 트랜잭션이란?

트랜잭션은 데이터베이스의 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위이다.

다시 말해, 데이터베이스 내에서 수행되는 작업의 최소 단위로, 데이터베이스의 무결성을 유지하여 DB의 상태를 변화시키는 기능을 수행한다.

즉, **SELECT, UPDATE, INSERT, DELETE와 같은 연산을 수행하여 데이터베이스의 상태를 변화시키는 작업의 단위**라고 생각하면 쉽다.

트랜잭션은 하나 이상의 query를 포함해야 하고, ACID라고 불리는 원자성, 일관성, 고립성, 지속성의 4가지 규칙을 만족해야한다.

**즉, 하나의 트랜잭션 설계를 잘 만드는 것이 데이터를 다룰 때 많은 이점을 가져다준다**.

---

### ACID

트랜잭션은 데이터베이스의 무결성을 유지하기 위해 원자성, 일관성, 고립성, 지속성의 성질을 는다.

### 🙆‍♂️무결성이란?

데이터의 정확성, 일관성, 유효성을 유지하는 것

무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실세계의 실제 값이 일치하는지에 대한 신뢰가 생긴다.

- 개체 무결성
  - 기본키로 선택된 필드는 빈 값을 허용하지 않는다
- 참조 무결성
  - 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야한다
- 고유 무결성
  - 특성 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가진다
- NULL무결성
  - 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약조건이다.

### 🙋트랜잭션의 특징

- **Atomicity(원자성)**
  - 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 말아야한다(all or nothing)
  - 트랜잭션 내의 모든 명령이 반드시 완벽하게 수행되어야한다
  - 하나라도 오류가 발생한다면 트랜잭션 전부가 취소된다
- **Consistency(일관성)**
  - 허용된 방식으로만 데이터를 변경해야한다
  - 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다
  - 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 후의 상태가 같아야한다
- **Isolation(고립성)**
  - 트랜잭션은 동시에 수행된다. 이때 각 트랜잭션은 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하여 독립적으로 작업을 수행해야 한다
  - 둘 이상의 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동해야한다
  - 따라서 동시에 수행되는 트랜잭션이 동일한 데이터를 가지고 충돌하지 않도록 제어해줘야한다(동시성 제어)
- **Durability(지속성)**
  - 성공적으로 수행된 트랜잭션은 영원히 반영되어야한다.
  - 시스템에 장애가 발생해도 원래 상태로 복구하는 회복기능이 있어야한다
  - 체크섬, 저널링, 롤백의 기능을 제공한다
    - 체크섬: 중복 검사의 한 형태/ 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
    - 저널링: 파일 시스템 또는 데이터베이스 시스템에 변경사항을 커밋하기 전에 로깅하는 것/ 트랜잭션 등 변경 사항에 대해 로그를 남기는 것
  ![1](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/5fa124a5-9e2d-4d40-b993-b80d11cb5fac)

### 동시성 제어(concurrency control)

여러 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 어느 한 트랜잭션의 갱신이 무효화 될 수 있는데 이를 갱신손실이라고 한다. 동시성 제어를 통해 갱신손실을 미리 막을 수 있다.

즉, 트랜잭션이 동시에 수행될 때 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능을 동시성 제어라고 한다.

갱실손실 문제를 해결하기 위한 방법중에 하나로 데이터를 수정중에 있는 트랜잭션은 해당 데이터를 lock으로 잠금장치를 하여 다른 트랜잭션이 접근하지 못하게 하는 방법이 있다.

lock이 걸린 데이터는 unlock이 될 때까지 다른 트랜잭션들은 접근하지 못하고 기다려야한다.

![2](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/6affbdbd-e456-44e8-912b-542c02ce888f)

![3](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/bf60d9e5-24b2-4976-b8ad-99e03c9719b9)

### 🤌커밋과 롤백

데이터베이스는 커밋과 롤백 명령어를 통해서 데이터 무결성을 보장한다.

커밋이란, 트랜잭션 작업을 완료했다고 확정하는 명령어이다. 트랜잭션 작업 내용을 실제 DB에 저장하고 DB가 변경된다.

롤백이란, 작업 중 문제가 발생했을 때, 트랜잭션 처리 과정에서 발생한 변경 사항을 취소하고 이전 커밋의 상태로 되돌린다.

- **커밋**
  - **여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어**이다.
  - 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성있는 상태에 있을 때 하나의 트랜잭션이 끝났음을 알려주기 위해 사용하는 연산이다.
  - 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것을 말한다.
  - 커밋이 수행되었다==하나의 트랜잭션이 성공적으로 수행되었다.
  ![4](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/9d49c96c-e3cc-4097-a513-63e947fbeacd)
- **롤백**
  - 하나의 트랜잭션 처리가 에러나 여러 이슈가 발생해서 트랜잭션 전으로 돌아갸아할 때(데이터베이스의 일관성이 깨졌을 때), 이 트랜잭션의 일부가 정상적으로 처리되었더라 하더라고 **트랜잭션의 원자성을 구성하기 위해 트랜잭션이 행한 모든 연상을 취소하는 연산**이다.

![5](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/8af59e7a-cf2f-4465-b1b5-0213f7cd28f3)

이러한 커밋과 롤백 덕분에 데이터의 무결성이 보잔된다. 또한 데이터 변경 전에 변경 사항을 쉽게 확인할 수 있고 해당 작업을 그룹화할 수 있다.

### 👩‍⚕️격리수준

![6](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/ca87f8d8-0ebb-4501-a370-0fc8d8f1c21b)

격리성 때문에 순차적으로 실행되는 것처럼 작동이 되어야한다.

**하지만 그냥 순차적으로 하면 쉽지만 성능이 안좋아진다**.

따라서 격리성은 여러개의 격리 수준으로 나뉘어 격리성을 보장한다.

위의 그림과 같은 격리수준이 있으며, 위로 올라갈수록 동시성이 강해지지만 격리성은 약해지고, 아래로갈수록 동시성은 약해지고 격리성은 강해진다.

**이 격리수준에 따라 발생하는 현상에는 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드**가 있다.

- 팬텀리드
  - 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회결과가 다른 경우
- 반복 가능하지 않은 조회
  - 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는 데 그 값이 다른 경우
  - 팬텀리드와 달리 행 값이 달라질 수도 있다
- 더티 리드
  - 반복 가능하지 않은 조회와 유사
  - 한 트랜잭션이 실행중일때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 행의 데이터를 읽을 수 있을 때 발생

**격리수준**

- SERIALIZABLE
- REPEATABLE_READ
- READ_COMMITTED
- READ_UNCOMMITTED
