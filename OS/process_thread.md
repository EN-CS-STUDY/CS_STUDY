## 프로세스와 스레드(Process vs Thread)

프로세스를 알기 전에 프로그램을 알아야한다.

📌**프로그램이란?**

파일이 저장 장치에 저장되어 있지만 메모리에는 올라가 있지 않은 정적인 상태이며, **어떠한 작업을 위해 실행할 수 있는 파일**을 뜻한다.

📌**프로세스란?**

프로그램이 메모리에 올라와 **운영체제로부터 CPU를 할당받고 프로그램이 실행되고 있는 상태**이다. 쉽게 말해 프로세스는 프로그램이 메모리에 올라가 인스턴스화 된 것을 말한다.

즉, 일을 처리하는 일련의 과정을 뜻한다.

- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 메모리에서 올라와 실행되고 있는 프로그램 인스턴스(독립적인 개체)
- 스케쥴링의 대상이 되는 작업과 같은 의미로 쓰임
- 하드디스크에 있는 프로그램을 실행하면, 실행을 위한 메모리할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라간다. 이 순간부터 프로세스라고 불린다.

예를 들어, 프로그램은 구글 크롬 프로그램(chrome.exe)과 같은 실행 파일이며, 이를 두 번 클릭하면 구글 크롬 프로세스로 변환되는 것이다.

프로그램을 만드는 과정은 언어마다 다를 수 있다. 예시로 컴파일 언어인 C언어 기반의 프로그램을 기준으로 설명해보면, 컴파일러가 컴파일 과정을 통해 컴퓨터가 이해할 수 있는 기계어로 번역하여 실행할 수 있는 파일을 만들게 된다.

전처리: 소스 코드의 주석을 제거하고 #include 등 헤더파일을 병합

컴파일러: 오류 처리, 코드 최적화 작업을 통해 어셈블리어로 변환

어셈블러: 어셈블리어는 목적코드로 변환

링커: 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합해 실행파일을 만든다.

### 📝프로세스의 context

프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 말한다.

현대의 운영체제는 여러 프로세스가 함께 수행되는 시분할 시스템 환경이다. 이 환경에서는 타이머 인터럽트에 의해 짧은 시간동안 cpu를 점유하고 다른 프로세스에게 넘겨주고 다시 차례가 되면 cpu를 점유하여 명령을 수행한다.

다시 명령을 수행하기 위해서 이전에 어디까지 명령을 수행했는지 정확한 수행 시점과 상태를 재현할 수 있는 정보가 필요하다. 이 정보가 바로 프로세스 문맥(context)이다.

프로세스 문맥은 크게 3가지로 **하드웨어 문맥**, **프로세스의 주소공간**, **커널상의 문맥**으로 나눌수가 있다.

**하드웨어 문맥은** CPU 수행 상태를 나타내는 것으로 **PC(Program Counter) 와 각종 레지스터**에 저장하고 있는 값들을 말한다.

**프로세스의 주소공간**은 코드, 데이터 ,스택으로 구성된 프로세스만의 독자적인 주소 공간을 말한다.

**커널상의 문맥**은 프로세스를 관리를 위한 자료구조인 **PCB(Process Control Block)와 Kernel stack(커널내의 주소)**을 말한다.

**📌프로세스의 메모리 구조**

1. **코드(Code) 영역:**

코드 영역은 실행할 프로그램의 코드 및 매크로 상수가 기계어 형태로 저장되는 영역이다.

CPU는 코드영역에 저장된 명령어를 하나씩 처리한다.

1. **데이터(Data) 영역:**

데이터 영역은 코드에서 선언한 전역 변수와 정적(static) 변수가 저장되는 영역이다.

데이터 영역은 프로그램의 시작과 함께 할당되어 종료될 때 소멸된다.

1. **스택(Stack) 영역:**

스택 영역은 함수 안에서 선언된 지역변수, 매개변수, 리턴값, 등이 저장되고 함수 호출시 기록하고 종료되면 제거한다. 스택이라는 자료구조 명칭에서도 알 수 있듯이 후위선출(LIFO) 메커니즘을 따른다.

흔히 재귀함수를 통해 너무 많은 함수를 호출하게 되는 경우 스택 영역이 초과하면서 Stack Overflow(스택오버플로우)에러가 발생한다.

1. **힙(Heap) 영역:**

힙 영역은 관리가 가능한 데이터 이외의 다른 형태의 데이터를 관리하기 위한 공간(Free Space)이다.

이 공간은 동적 메모리 할당 공간이므로 사용이 끝나면 운영체제가 쓸수 있도록 반납해야 한다.

프로그램이 실행하는 순간 프로그램이 사용할 메모리 크기를 고려하여 메모리의 할당이 이루어지는 데이터 또는 스택과 같은 정적 메모리 할당과는 대조적이다.

동적 메모리 할당은 어느 시점에 어느 정도의 공간을 할당할 수 있을지 정확히게 예측할 수 없으므로, 런타임에 확인가능하다.

**📌IPC(Inter-Process Communicatoin)이란?**

각 프로세스는 별도의 공간에서 실행되기 때문에, 한 프로세스에서 다른 프로세스의 메모리영역에 접근할 수 없다. 만약 프로세스가 다른 프로세스 자원에 접근하려면 IPC(Inter-Process Commnuication)를 사용해야 한다.

IPC란 운영체제 상에서 실행 중인 프로세스 간에 정보를 주고받는 것을 말한다. 프로세스는 자신에게 할당된 메모리 내의 정보만 접근할 수 있는데, 이는 안전성을 위해 운영체제에서 자기 프로세스의 메모리만 접근하도록 강제하고 있다는 것이다.

**📌PCB(Process Control Block)란?**

운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조를 말한다.

### 📝프로세스의 상태(state)

시분할 시스템 환경에서 프로세스의 상태는 **실행(running)**, **준비(ready)**, **봉쇄(blocked, wait, sleep)**의 세 가지로 구분할 수 있다.

**실행(Running):** 프로세스가 CPU를 잡고 기계어 명령을 수행중인 상태

**준비(Ready):** CPU만 보유하면 당장 명령을 수행 할 수 있도록 (메모리 등 다른 조건을 모두 만족) CPU를 기다리는 상태

**봉쇄(blocked, wait, sleep):** CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태이다.  I/O 등의 event를 (스스로) 기다려야 하거나 디스크에서 file을 읽어와야 하는 경우가 봉쇄상태

위에서 말한 3가지 프로세스 상태 외에도 다음과 같은 프로세스 상태가 존재한다.

**시작 상태:** 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태

**완료 상태:** 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태

**Suspended (stoped)**

- 외부적인 이유로 프로세스의 수행이 정지된 상태
- 프로세스는 통째로 디스크에 swap out 된다
- ex) 사용자 프로그램을 일시 정지시킨 경우 (break key) 시스템이 여러 이유로 프로세스를 잠시 중단시킴(메모리에 너무 많은 프로세스가 올라와 있을 때)

> Blocked: 자신이 요청한 event가 만족되면 Ready
>
> Suspended: 외부에서 resume해 주어야 Active

### 🔶멀티태스킹

위의 그림을 살펴보면 여러 프로세스가 동시에 실행되고 관리 되는 것처럼 보이지만, **사실 cpu는 한번에 한가지 명령어밖에 처리하지 못한다**. 즉, **동시가 아닌 재빠르게 프로세스들을 번갈아가며 실행하고 관리하는 것이다**.

cpu는 상상이상으로 빠르기 때문에 프로세스들을 번갈아가면서 관리하는 것이 마치 동시에 하는 것처럼 보일 뿐이다. 이를 **Context Switching**이라고 한다.

**📍Context Switching**

시분할 시스템에서 프로세스의 cpu점유가 끝나면 다른 프로세스로 cpu를 넘겨주게 되는데 이때 문맥교환이 발생한다.

- 하나의 프로세스가 cpu를 사용 중인 상태에서 다른 프로세스가 cpu를 사용하도록 하기 위해, 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업
- System call이나 interrupt 발생시 반드시 context switch가 일어나는 것은 아니다.
- 운영체제의 cpu자원을 할당하는 **스케줄러**에 의해 발생한다. **cpu를 적절하고 효율적으로 사용할 수 있도록 하는 작업을 스케줄링**이라고 한다.
- 문맥교환이 발생하며CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행한다.
  - CPU를 내어주는 프로세스의 문맥(context)를 그 프로세스의 PCB에 저장
  - CPU를 새롭게 얻는 프로세스의 문맥(context)을 PCB로부터 읽어 실제 하드웨어로 복원

**📍CPU Scheduler**

운영체제는 하드웨어와 소프트웨어 자원을 줄세우기 위해서 여러 큐를 두고 사용한다. 프로세스들은 각 큐를 오가며 수행된다.

**Job queue**

- 현재 시스템 내에 있는 모든 프로세스의 집합

**Ready queue**

- 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합

**Device queues**

- I/O device의 처리를 기다리는 프로세스의 집합

스케줄링의 목적은 다음과 같다.

1. cpu를 최대한 활용하기
2. 대기 시간을 최소화하기
3. 처리량을 최대화하기

이 스케쥴링은 멀티 태스킹 작업을 만들어내는데 있어서 핵심적인 개념이다. 스케쥴링을 구현하는 데는 반드시 자료구조의 구현이 따르는데, 어떤 자료구조를 이용하는 지가 스케쥴링의 중요한 요소들이다.
