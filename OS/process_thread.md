## 프로세스와 스레드(Process vs Thread)

프로세스를 알기 전에 프로그램을 알아야한다.

📌**프로그램이란?**

파일이 저장 장치에 저장되어 있지만 메모리에는 올라가 있지 않은 정적인 상태이며, **어떠한 작업을 위해 실행할 수 있는 파일**을 뜻한다.

📌**프로세스란?**

프로그램이 메모리에 올라와 **운영체제로부터 CPU를 할당받고 프로그램이 실행되고 있는 상태**이다. 쉽게 말해 프로세스는 프로그램이 메모리에 올라가 인스턴스화 된 것을 말한다.

즉, 일을 처리하는 일련의 과정을 뜻한다.

- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 메모리에서 올라와 실행되고 있는 프로그램 인스턴스(독립적인 개체)
- 스케쥴링의 대상이 되는 작업과 같은 의미로 쓰임
- 하드디스크에 있는 프로그램을 실행하면, 실행을 위한 메모리할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라간다. 이 순간부터 프로세스라고 불린다.

예를 들어, 프로그램은 구글 크롬 프로그램(chrome.exe)과 같은 실행 파일이며, 이를 두 번 클릭하면 구글 크롬 프로세스로 변환되는 것이다.

프로그램을 만드는 과정은 언어마다 다를 수 있다. 예시로 컴파일 언어인 C언어 기반의 프로그램을 기준으로 설명해보면, 컴파일러가 컴파일 과정을 통해 컴퓨터가 이해할 수 있는 기계어로 번역하여 실행할 수 있는 파일을 만들게 된다.

전처리: 소스 코드의 주석을 제거하고 #include 등 헤더파일을 병합

컴파일러: 오류 처리, 코드 최적화 작업을 통해 어셈블리어로 변환

어셈블러: 어셈블리어는 목적코드로 변환

링커: 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합해 실행파일을 만든다.

### 📝프로세스의 context

프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 말한다.

현대의 운영체제는 여러 프로세스가 함께 수행되는 시분할 시스템 환경이다. 이 환경에서는 타이머 인터럽트에 의해 짧은 시간동안 cpu를 점유하고 다른 프로세스에게 넘겨주고 다시 차례가 되면 cpu를 점유하여 명령을 수행한다.

다시 명령을 수행하기 위해서 이전에 어디까지 명령을 수행했는지 정확한 수행 시점과 상태를 재현할 수 있는 정보가 필요하다. 이 정보가 바로 프로세스 문맥(context)이다.

프로세스 문맥은 크게 3가지로 **하드웨어 문맥**, **프로세스의 주소공간**, **커널상의 문맥**으로 나눌수가 있다.

**하드웨어 문맥은** CPU 수행 상태를 나타내는 것으로 **PC(Program Counter) 와 각종 레지스터**에 저장하고 있는 값들을 말한다.

**프로세스의 주소공간**은 코드, 데이터 ,스택으로 구성된 프로세스만의 독자적인 주소 공간을 말한다.

**커널상의 문맥**은 프로세스를 관리를 위한 자료구조인 **PCB(Process Control Block)와 Kernel stack(커널내의 주소)**을 말한다.

**📌프로세스의 메모리 구조**

1. **코드(Code) 영역:**

코드 영역은 실행할 프로그램의 코드 및 매크로 상수가 기계어 형태로 저장되는 영역이다.

CPU는 코드영역에 저장된 명령어를 하나씩 처리한다.

1. **데이터(Data) 영역:**

데이터 영역은 코드에서 선언한 전역 변수와 정적(static) 변수가 저장되는 영역이다.

데이터 영역은 프로그램의 시작과 함께 할당되어 종료될 때 소멸된다.

1. **스택(Stack) 영역:**

스택 영역은 함수 안에서 선언된 지역변수, 매개변수, 리턴값, 등이 저장되고 함수 호출시 기록하고 종료되면 제거한다. 스택이라는 자료구조 명칭에서도 알 수 있듯이 후위선출(LIFO) 메커니즘을 따른다.

흔히 재귀함수를 통해 너무 많은 함수를 호출하게 되는 경우 스택 영역이 초과하면서 Stack Overflow(스택오버플로우)에러가 발생한다.

1. **힙(Heap) 영역:**

힙 영역은 관리가 가능한 데이터 이외의 다른 형태의 데이터를 관리하기 위한 공간(Free Space)이다.

이 공간은 동적 메모리 할당 공간이므로 사용이 끝나면 운영체제가 쓸수 있도록 반납해야 한다.

프로그램이 실행하는 순간 프로그램이 사용할 메모리 크기를 고려하여 메모리의 할당이 이루어지는 데이터 또는 스택과 같은 정적 메모리 할당과는 대조적이다.

동적 메모리 할당은 어느 시점에 어느 정도의 공간을 할당할 수 있을지 정확히게 예측할 수 없으므로, 런타임에 확인가능하다.

**📌IPC(Inter-Process Communicatoin)이란?**

각 프로세스는 별도의 공간에서 실행되기 때문에, 한 프로세스에서 다른 프로세스의 메모리영역에 접근할 수 없다. 만약 프로세스가 다른 프로세스 자원에 접근하려면 IPC(Inter-Process Commnuication)를 사용해야 한다.

IPC란 운영체제 상에서 실행 중인 프로세스 간에 정보를 주고받는 것을 말한다. 프로세스는 자신에게 할당된 메모리 내의 정보만 접근할 수 있는데, 이는 안전성을 위해 운영체제에서 자기 프로세스의 메모리만 접근하도록 강제하고 있다는 것이다.

### Multi process

Multi process란 2개 이상의 process가 동시에 실행되는 것을 말한다. 동시에라는 말은 동시성(concurrency)과 병렬성(parallelism) 두 가지를 의미한다.

동시성은 CPU core가 1개일 때, 여러 process를 짧은 시간동안 번갈아 가면서 연산을 하게 되는 시분할 시스템(time sharing system)으로 실행되는 것이다.

병렬성은 CPU core가 여러개일 때, 각각의 core가 각각의 process를 연산함으로써 process가 동시에 실행되는 것이다.

### 동시성(Concurrency) vs 병렬성(Parallelism)

![화면 캡처 2024-06-18 183611](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/c9a7ac8d-9c56-4f24-aca9-e34ee80bd99e)
![화면 캡처 2024-06-18 183712](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/62e1a8ad-598b-4a4d-96c6-adbdd78bbcec)

| 동시성                          | 병렬성                              |
| ------------------------------- | ----------------------------------- |
| Single core                     | Multi core                          |
| 동시에 실행되는 것 같아 보인다. | 실제로 동시에 여러 작업이 처리 된다 |
| 싱글 코어에서 멀티 스레드       | 멀티 코어에서 멀티 스레드           |
| 논리적인 개념                   | 물리적인 개념                       |

요새 쓰는 노트북이나 컴퓨터들은 CPU core가 여러개 있다. core가 여러개 있어서 실제로 여러 process가 동시에 처리되는 것을 병렬성이라고 한다. 당연히 한 개의 CPU core는 당연히 한 번에 하나의 연산밖에 못한다. 동시에 여러 process를 처리하는 것은 동시성이라고 한다.

### Multi process

Multi process란 2개 이상의 process가 동시에 실행되는 것을 말한다. 이 때 process들은 CPU와 메모리를 공유하게 된다.

memory의 경우에는 여러 process들이 각자의 memory영역을 차지하여 동시에 적재된다.

반면 하나의 CPU는 매 순간 하나의 process만 연산할 수 있다. 하지만 CPU의 처리 속도가 워낙 빨라서 수 ms 이내의 짧은 시간동안 여러 process들이 CPU에서 번갈아 실행되기 때문에 사용자 입장에서는 여러 프로그램이 동시에 실행되는 것처럼 보인다. 이처럼 CPU의 작업시간을 여러 process들이 조금씩 나누어 쓰는 시스템을 시분할 시스템(time sharing system)이라고 부른다.

### 메모리관리

여러 process가 동시에 memory에 적재된 경우, 서로 다른 process의 영역을 침범하지 않도록 각 process가 자신의 memory영역에만 접근하도록 운영체제가 관리해준다.

![22222 001](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/5c05158b-dbb8-4522-b408-8f6fdabc1e3d)

### CPU의 연산과 PC register

CPU는 PC(Program counter) register가 가리키고 있는 명령어를 읽어들여 연산을 진행한다. PC register에는 다음에 실행될 명령어의 주소값이 저장되어 있다. PC register는 CPU에 있다. multi process시스템에서는 process1이 진행되고 있을 때는 process1의 code 영역을 PC register가 가리키다가, process2가 진행되면 process2의 code 영역을 가리키게 된다. CPU는 PC register가 가리키는 곳에 따라 process를 변경해 가면서 명령어를 읽어들이고 연산을 하게 된다.
![화면 캡처 2024-06-18 183827](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/ddd73e76-bbd0-4c27-9e06-d8d8eea20d68)

### Context

프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 말한다. 현대의 운영체제는 여러 프로세스가 함께 수행되는 시분할 시스템이다. 시분할 시스템 환경에서는 타이머 인터럽트에 의해 짧은 시간동안 CPU를 점유하고 다른 프로세스에게 넘겨주고 다시 차례가 되면 CPU를 점유하여 명령을 수행한다. 다시 명령을 수행하기 위해서 이전에 어디까지 명령을 수행했는지 정확한 수행 지점과 상태를 재현할 수 있는 정보가 필요하다. 이 정보가 Context이다.

쉽게 말해, 시분할 시스템에서는 한 process가 매우 짧은 시간동안 CPU를 점유하여 일정부분의 명령을 수행하고, 다른 프로세스에게 넘긴다. 그 후 차례가 되면 다시 CPU를 점유하여 명령을 수행한다. 따라서 이전에 어디까지 명령을 수행했고, register에는 어떤 값이 저장되어 있었는지에 대한 정보가 필요하게 된다. process가 현재 어떤 상태로 수행되고 있는지에 대한 총체적인 정보가 바로 \*\*\*\*context다. context 정보들은 PCB(Process Control Block)에 저장을 한다.

### PCB(Process Control Block)

PCB는 운영 체제가 프로세스를 표현한 자료구조다. PCB에는 프로세스의 중요한 정보가 포함되어 있기 때문에, 일반 사용자가 접근하지 못하도록 보호된 메모리 영역 안에 저장이 된다. 일부 운영 체제에서 PCB는 커널 스택에 위치한다. 이 메모리 영역은 보호를 받으면서도 비교적 접근하기가 편리하기 때문이다.

PCB에는 일반적으로 다음과 같은 정보가 포함된다.

![Untitled](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/4884dcf0-05c0-471b-9ba7-2e69a9877c27)

| PCB                 |                                                                 |
| ------------------- | --------------------------------------------------------------- |
| Process State       | new, running, waiting, halted 등의 state가 있다.                |
| Process Number      | 해당 process의 number                                           |
| Program counter(PC) | 해당 process가 다음에 실행할 명령어의 주소를 가리킨다           |
| Registers           | 컴퓨터 구조에 따라 다양한 수와 유형을 가진 register 값들        |
| Memory limits       | base register, limit register, page table 또는 segment table 등 |
| ...                 |                                                                 |

![Multi process에 대해서 설명해주세요 001](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/8a3b6017-2fa7-4492-892a-6a6f88fd9fb8)

### Context switch

Context switch란 한 프로세스에서 다른 프로세스로 **CPU 제어권을 넘겨**주는 것을 말한다.

컨텍스트 스위칭의 동작과정은 3가지로 나눌 수 있다.

> 1. 현재 실행 중인 프로세스의 상태 정보 저장

> 2. 다음으로 실행할 프로세스의 상태 정보 복원

> 3. 실행 중인 프로세스 교체

CPU가 현재 작업 중인 프로세스에서 다른 프로세스로 넘어갈 때 지금까지의 프로세스의 상태를 저장하고, 새 프로세스의 저장된 상태를 다시 적재하는 작업을 Context Switch라고 부른다. (프로세스의 정보는 PCB에 저장)

이 때 이전의 프로세스의 상태를 **PCB에 저장하여 보관**하고 \***\*새로운 프로세스의 **PCB를 읽어서 보관된 상태를 복구\*\*하는 작업이 이루어진다.

![Multi process에 대해서 설명해주세요 001](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/fa446908-d0cd-4c87-87e1-2b281e0e177f)

Context Switching을 하는 동안 CPU는 아무일도 하지않는 시간이 발생하는데, 이를 오버헤드라고 부르고 오버헤드가 잦아지면 성능이 떨어질 수 있다.
