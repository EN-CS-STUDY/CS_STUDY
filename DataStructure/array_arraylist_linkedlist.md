## 작성자 : 홍영환
# Array vs ArrayList vs LinkedList

---

## **📚 Array**

---

> 동일한 데이터 타입의 요소를 **순차적으로 저장**하는 자료구조.
> 

![Untitled](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/5eb28c32-d3c7-46de-8180-b0da77e1c2b8)

- **고정 크기 :** 배열이 생성 후 크기 변경 x

**장점**

- **접근 속도**: 인덱스를 이용해 O(1) 시간 복잡도로 요소에 접근할 수 있습니다.
- **메모리 사용**: 요소들이 연속된 메모리 공간에 저장되어 있어 메모리 사용이 효율적입니다.

**단점**

- **삽입 및 삭제**: 배열의 중간에 요소를 삽입하거나 삭제하는 것은 O(n) 시간이 소요됩니다.

## **📚 ArrayList**

---

> 동적 배열로, 크기를 동적으로 조절할 수 있는 배열 기반의 자료구조.
> 

![Untitled](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/5eb28c32-d3c7-46de-8180-b0da77e1c2b8)

- **크기**: 초기 크기를 지정할 수 있으며, 데이터가 추가됨에 따라 크기가 자동으로 늘어난다.

**장점**

- **동적 크기**: 필요에 따라 크기가 자동으로 조절되어 메모리 낭비를 줄일 수 있다.
- **접근 속도**: 배열과 마찬가지로 인덱스를 이용해 O(1) 시간 복잡도로 요소에 접근할 수 있다.

**단점**

- **삽입 및 삭제**: 배열처럼 중간에 요소를 삽입하거나 삭제하는 것은 O(n) 시간이 소요된다.
- **성능 저하**: 크기가 커지면 재할당과 복사 작업이 빈번히 발생해 성능 저하가 일어날 수 있다.

## **📚 LinkedList**

---

> 노드가 서로 연결된 형태의 자료구조. 각 노드는 데이터와 다음 노드를 가리키는 포인터로 구성됩니다.
> 

**단일 연결 리스트(Singly Linked List),** 

**이중 연결 리스트(Doubly Linked List)** 등 여러 종류가 있다.

**장점**

- **동적 크기**: 크기가 동적으로 조절되어 메모리 효율적이다.
- **삽입 및 삭제**: 중간에 요소를 삽입하거나 삭제하는 것이 O(1) 시간 복잡도로 가능하다. (삽입 위치를 알고 있는 경우).

**단점**

- **접근 속도**: 특정 인덱스에 접근하려면 처음부터 순차적으로 접근해야 하므로 O(n) 시간이 소요된다.
- **메모리 사용**: 각 노드가 추가적인 포인터를 저장하기 때문에 배열보다 메모리 사용이 비효율적일 수 있습니다.

## **📚 요약**

---

- **Array**: 고정 크기, 빠른 접근, 삽입/삭제가 비효율적.
- **ArrayList**: 동적 크기, 빠른 접근, 삽입/삭제가 중간 정도 효율적.
- **LinkedList**: 동적 크기, 느린 접근, 빠른 삽입/삭제.

## **📚 선택 기준**

---

**Array**: 데이터 크기가 고정되고, 주로 읽기 작업이 많은 경우.

**ArrayList**: 데이터 크기가 변동 가능하고, 읽기와 쓰기 작업이 모두 많은 경우.

**LinkedList**: 데이터 삽입과 삭제가 빈번히 일어나고, 순차적으로 데이터를 처리하는 경우.

## 🤔 Array vs ArrayList 차이

---

Array와 ArrayList는 모든 것이 비슷하다. 

> **가장 큰 차이점은 길이를 조정할 수 있는가? 없는가?** 이다.
> 

- Array는 **고정 길이**이다.
- ArrayLisy는 **가변 길이**이다.

Array는 초기화 시 메모리에 할당되어 ArrayList보다 속도가 빠르고,
ArrayList는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 Array보다 느리다.

### 📌 ArrayList의 원리

---

ArrayList는 Default로 10개의 공간을 가진 배열로 시작한다. 하지만 최적화로 인해 막 생성하면 0개이 사이즈로 시작된다. 

각각의 ArrayList Object는 ArrayList의 size를 나타내는 **capacity 인스턴스 변수**를 가지고 있다. 요소들이 더해지면 capacity 또한 자동으로 증가한다. 만약 설정한 용량을 넘어선 객체가 들어오면 **배열 크기를 1.5배 증가**시킨다.

|  | array | arrayList |
| --- | --- | --- |
| 사이즈 | 초기화시 고정 | 초기화시 사이즈를 표시하지 않음. 사이즈가 동적이다. |
| 속도 | 초기화 시 메모리에 할당되어 속도 빠름 | 추가시 메모리를 재할당하여 속도가 느림 |
| 변경 | 사이즈 변경 불가 | 추가,삭제 가능 |
| 다차원 | 가능 | 불가능 |
| 타입 | primitive type(int,byte, char etc), object | object elemnet만 가능 |
| 제네릭 | 사용 불가능 | 사용 가능(타입 안정성 보장) |
| 길이 | length 변수 | size() 메서드 |
| 변수 추가 | assignment 연산자 사용 | add() 메소드 사용 |

## 🤔 ArrayList vs LinkedList 차이

---

![Untitled](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/c2f76dc8-acc1-4f93-8de4-2540a7d411c4)

ArrayList는 index가 있고, LinkedList는 각 원소마다 앞, 뒤 원소의 위치값을 가지고 있다.

### ✅ 삽입, 삭제, 값 가져오기 시간복잡도

![Untitled](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/f6fc35d6-2072-474c-a678-9560715c57ec)

---

### ✅ ArrayList

**조회**

> 각 데이터의 index를 가지고 있어 해당 index의 데이터를 한번에 가져올 수 있다.
> 

**데이터 삽입과 삭제**

> 데이터 삽립과 삭제시 ArrayList는 그만큼 위치를 맞춰주어야 한다.
> 

예를 들어, 5개의 데이터가 있을 때 맨 앞의 2를 삭제했다면 나머지 뒤의 4개를 앞으로 한칸씩 이동해야 한다.

→ **삽입과 삭제가 많다면 비효율적**

---

### ✅ LinkedList

배열의 단점을 보완하기 위해 LinkedList 고안

**조회**

> LinkedList는 index 없이 순차적 접근이기 때문에 검색 속도가 느리다.
> 

**데이터 삽입과 삭제**

> 가리키고 있는 주소값만 변경해주면 되기 때문에 상당히 효율적이다
> 

## 📊 성능 비교

![Untitled](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/d3e4f227-02e2-49d9-a87c-2a2bdf09bb05)
삽입 삭제 : LinkedList가 더 뛰어난 성능을 보여준다.

조회 : ArrayList가 더 뛰어난 성능을 보여준다.


## 📚 참고자료


https://dev-coco.tistory.com/159

https://dev-coco.tistory.com/19

