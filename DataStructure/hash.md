### 작성자 : 조준희

## 해시(Hash)

### 해시란?
- 임의의 크기를 가진 데이터를 고정된 데이터의 크기로 변환시키는 것
- 해시를 사용하면 즉시 저장하거나 찾고자 하는 위치를 참조하므로 향상된 속도로 처리가 가능
- Hash Or HashTable은 내부적으로 배열을 사용해 데이터를 저장한다.
- 인덱스를 사용하여 빠른 검색속도를 갖는다.

### 해시 함수
- 해시 함수란 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
- 해시 함수에 의해 얻어지는 값을 해시 코드, 해시라고 한다.

### 해시 테이블
- 해시 테이블은 해시 함수를 사용하여 데이터를 저장하는 자료구조
- 해시 함수로 얻은 해시를 키로 활용하여 index로 사용하고 해당 index에 데이터를 저장하여 효율적인 검색을 위해 사용됨
- key, value에 널 값을 허용하지 않음

해시의 예시로는 다음과 같다.


```
1. Lee → 해시함수 → 5
2. Kim → 해시함수 → 3
3. Park → 해시함수 → 7
...
이렇게 계속해서 해시함수를 저장하다 보면 다음과 같이 충돌(collision)이 발생할 경우가 생긴다.

4. Cho → 해시함수 → 3

위에서 2번과 4번에서 충돌이 발생하는 경우가 생긴다. 
이 충돌 해결법으로 대표적으로 2가지가 있다.
```

## 충돌(collision) 해결법
### 1. Open Address 방식 (개방주소법)

```
해시 충돌이 발생하면, (즉 삽입하려는 해시 버킷이 이미 사용 중인 경우) 다른 해시 버킷에 해당 자료를 삽입하는 방식 이다. 
버킷이란 바구니와 같은 개념으로 데이터를 저장하기 위한 공간이라고 생각하면 된다. 
다른 해시 버킷이란 어떤 해시 버킷을 말하는 것인가?

공개 주소 방식이라고도 불리는 이 알고리즘은 Collision 이 발생하면 데이터를 저장할 장소를 찾아 헤맨다. 
Worst Case 의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다. 
이 과정에서도 여러 방법들이 존재하는데, 다음 네 가지에 대해 알아보자.

1. 선형 탐사(Linear Probing)
- 현재 주소에서 고정 크기(ex.1)만큼 다음 주소로 이동하여 데이터를 저장한다.

2. 제곱 탐사(Quadratic Probing)
- 고정 크기만큼 이동하는 것이 아닌 이동 크기가 제곱수로 늘어나는 방식이다. (1,4,9,16...)

3. 이중 해싱(Double Hashing)
- 해시 충돌 시 다른 해시 함수를 한번 더 적용하는 방식이다.

4. 재해싱(Rehashing)
- 해시 테이블의 크기를 늘리고, 늘어난 해시 테이블의 크기에 맞추어 모든 데이터를 다시 해싱하는 방식이다.

개방주소법의 문제점

데이터 A를 저장하고 데이터 B를 저장할 때 충돌(A와 같은 값)이 발생한다고 가정하자.
이때, 데이터 A가 삭제될 경우 찾으려고 하는 index를 찾기 전에 데이터가 삭제되어서 검색을 멈추기 때문에 데이터 B를 조회할 수 없게 된다.

이러한 문제점을 해결하기 위해 데이터를 삭제한 후에 더미 노드를 삽입한다. 
실제로 값을 가지진 않지만 검색 시 다음 index까지 연결하는 역할을 한다. 
데이터 삭제가 빈번하여 더미 노드가 증가한 경우, 조회할 데이터가 존재하지 않음에도 불구하고 더미 노드 때문에 검색을 수행하므로 더미 노드가 일정 갯수가 넘어가면 해시 테이블을 리빌딩해야 한다.
```

### 2. Separate Chaining 방식 (분리 연결법)
<img src = "https://github.com/EN-CS-STUDY/CS_STUDY/assets/48996701/66a52b8b-919a-4499-b49d-43ce7a9adf4c" alt="hash"/>

```
1. 연결 리스트를 사용하는 방식(Linked List) 
각각의 버킷(bucket)들을 연결리스트(Linked List)로 만들어 충돌이 발생하면 해당 버킷 리스트에 추가하는 방식이다. 
연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입이 간단하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드가 부담이 된다. 
또 다른 특징으로는, 버킷을 계속해서 사용하는 개방주소법에 비해 테이블의 확장을 늦출 수 있다.
데이터를 검색할 때, 선형 탐색을 하기 때문에 느리다는 단점이 있다. 시간 복잡도 : O(N)

Note) 오버헤드 예시 
만약 각 노드가 4바이트의 데이터를 저장하고, 포인터가 8바이트를 차지한다고 가정하면, 데이터 자체보다 포인터가 더 많은 메모리를 차자히게 되어 메모리 오버헤드가 발생 

2. Tree 를 사용하는 방식 (Red-Black Tree) 
기본적인 알고리즘은 Separate Chaining 방식과 동일하며 연결 리스트 대신 트리를 사용하는 방식이다. 
연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 
데이터의 개수가 적다면 연결리스트를 사용하는 것이 맞다. 트리는 기본적으로 메모리 사용량이 많기 때문이다. 
데이터 개수가 적을 때 Worst Case 를 살펴보면 트리와 연결리스트의 성능 상 차이가 거의 없다. 
따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 연결리스트를 사용한다.

따라서 다음과 같은 기준을 적용한다.
1. 데이터 개수가 적을 때는 연결리스트를 사용한다.
2. 데이터 개수가 많을 때는 트리를 사용한다.
```






### 정리 

#### 해시란?
- Hash(해시)는 데이터를 고정된 크기의 고유한 값으로 변환시키는 함수.
- Key-Value로 이루어진 데이터를 해시함수를 통해 해시값으로 변환하여 저장하는 자료구조

#### 해시에서 2가지 충돌해결법
1. 개방주소법 (Open Address)
2. 분리연결법 (Separate Chaining)

#### 개방주소법 (Open Address) vs 분리 연결법 (Separate Chaining)

- 두 방식 모두 Worst Case 에서 O(N) 
- 개방 주소법은 연속된 공간에 데이터를 저장하기 때문에 분리 연결법에 비해 캐시 효율이 높다. 
- 데이터의 개수가 충분히 적다면 개방 주소법이 분리 연결법보다 더 성능이 좋다. 
- 한 가지 차이점은 분리 연결법에 비해 개방 주소법은 버킷을 계속해서 사용한다. 
  - 따라서 분리연결법 방식은 테이블의 확장을 보다 늦출 수 있다.

#### 분리 연결법에서 연결리스트 vs 트리 언제 사용할까?
- 데이터 개수가 적을 때는 연결리스트를 사용한다.
- 데이터 개수가 많을 때는 트리를 사용한다.
- 데이터가 적다는 것은 얼마나 적다는 것을 의미하는가? 
  - 데이터 개수가 8개 이하일 때는 연결리스트를 사용한다. 
  - 데이터 개수가 8개 초과일 때는 트리를 사용한다.
  - 위의 기준은 JDK 1.8이 채택해서 사용중

#### 좋은 hash function의 조건은?
- 각 상황마다 good hash function은 달라질 수 있으나 대략적인 기준은 연산 속도가 빨라야 하고, 해시값이 최대한 겹치지 않아야 함

#### 해시 테이블을 쓰는 이유는?
- 해시 테이블은 데이터를 저장하고 검색하는데 있어서 O(1)의 시간복잡도를 가지기 때문에 빠른 검색이 가능함
- 언제나 동일한 해시값 리턴, index를 알면 빠른 데이터 검색이 가능해짐

#### 자바에서 해시 예시들
- HashMap
  - Key는 중복될 수 없으며, Value는 중복될 수 있음
  - null 값을 허용 (Key와 Value 둘 다 허용)
  - 순서를 보장하지 않음
  - HashMap은 많은 양의 데이터를 빠르게 검색할 수 있으며, 삽입과 삭제도 빠르게 가능하지만 해시 충돌이 발생할 경우 검색 성능이 저하될 수 있으므로 충돌을 최소화할 수 있는 해시함수를 사용해야 함

- HashSet
  - 내부적으로 HashMap을 사용
  - 요소들은 순서를 보장하지 않음
  - null 값을 허용
  - 중복된 값은 허용하지 않음
  - HashSet은 데이터베이스나 파일 시스템 등에서 중복된 값을 제거하거나, 대용량 데이터 중에서 특정 값을 찾을 때 유용하게 사용될 수 있음


참고자료
- https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data%20Structure/%5BData%20Structure%5D%20Hash(%ED%95%B4%EC%8B%9C).md
- https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/Hash.md
- https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/main/DataStructure#hash-table
- https://github.com/devSquad-study/2023-CS-Study/blob/main/Algorithm/algorithm_hash.md