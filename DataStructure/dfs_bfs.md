### 작성자 : 홍영환

# 완전탐색
---

> **모든 가능한 경우의 수**를 탐색하여 **최적의 결과**를 찾는 방법을 의미한다.
> 

모든 가능성을 고려하기 때문에 항상 최적의 해를 찾을 수 있지만 경우의 수가 매우 많은 경우 시간과 메모리의 부담이 커질 수 있습니다. 그렇기에 문제의 특성에 따라 다른 탐색 기법을 사용하는 것이 좋다.

## 📚 완전 탐색의 종류

---

![Untitled](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/83a60a08-fa3a-4ebb-be22-b8c280d9d9ff)

| 알고리즘 종류 | 설명 | 장점 | 단점 |
| --- | --- | --- | --- |
| 브루트 포스 | ‘모든 경우의 수를 탐색’하면서 원하는 결과를 얻는 알고리즘을 의미합니다. | 가능한 모든 경우를 다 검사하기 때문에 예상된 결과를 얻을 수 있음 | 경우의 수가 많을 경우 시간이 오래 걸림 |
| 비트마스크 | ‘모든 경우의 수를 이진수로 표현‘하고 ‘비트 연산’을 통해 원하는 결과를 빠르게 얻는 알고리즘을 의미합니다. | 이진수 연산을 이용하여 계산 속도가 빠름 | 경우의 수가 많아질수록 메모리 사용량이 늘어남 |
| 백트래킹 | 결과를 얻기 위해 진행하는 도중에 ‘막히게 되면’ 그 지점으로 다시 돌아가서 ‘다른 경로를 탐색’하는 방식을 의미합니다. 결국 모든 가능한 경우의 수를 탐색하여 해결책을 찾습니다. | 경우의 수를 줄이면서도 모든 경우를 탐색할 수 있음 | 재귀 함수를 이용하기 때문에 스택 오버플로우가 발생할 가능성 있음 |
| 순열 | ‘순열을 이용하여 모든 경우의 수를 탐색‘하는 방법입니다. 순열은 서로 다른 n개 중에서 r개를 선택하여 나열하는 방법을 의미합니다 | 경우의 수가 적을 때 사용하면 유용함 | 경우의 수가 많을 경우 시간이 오래 걸림 |
| 재귀함수 | ‘자기 자신을 호출‘하여 모든 가능한 경우의 수를 체크하면서 최적의 해답을 얻는 방식을 의미합니다. | 코드가 간결하며, 이해하기 쉽습니다. | 스택 오버플로우가 발생할 가능성이 있음 |
| DFS/BFS | 깊이 우선 탐색(DFS: Depth-First Search)- 루트 노드에서 시작하여 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법을 의미합니다.너비 우선 탐색(Breadth-First Search: BFS)- 루트 노드에서 시작하여 인접한 노드를 먼저 탐색하는 방법을 의미합니다. | 미로 찾기 등에 유용함 | 최악의 경우, 모든 노드를 다 방문해야 하므로 시간이 오래 걸림 |

## 📕 브루트 포스 (Brute-Force)

---

> **모든 경우를 다 탐색**하면서 결과를 얻는 알고리즘이다.
> 

예를들어 좌물쇠의 비밀번호를 알 수 없는 경우 모든 경우를 대입하며 비밀번호를 찾아가는 경우가 있다.

## 📕 **비트마스크(Bitmask)**

---

> **이진수의 비트 연산**을 통해 경우의 수를 줄여가며 탐색하는 방식을 의미한다.
> 

비트 마스크를 사용하면 하나의 변수에 여러 개의 상태 정보를 저장할 수 있으며, 이를 통해 복잡한 조건문을 간단하게 처리할 수 있다. 비트 연산을 사용하기 때문에 빠르게 계산할 수 있어서 경우의 수가 많은 경우에 유용하다.

### **🧐 완전 탐색에서 비트마스크란?**

- 모든 경우의 수를 이진수로 표현하여 빠르게 계산해 나아가는 방식이다.

### ✏️ 비트 연산 종류

| A | B | A & B | A | B | ~A | A ^ B |
| --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 | 0 | 0 |

**And 연산(&) : 둘 다 1이면 1**

**OR 연산(|) : 둘 중 1개만 1이면 1**

**NOT 연산(~) : 1이면 0, 0이면 1**

**XOR 연산(^) : 둘의 관계가 다르면 1, 같으면 0**

**Shift 연산(<<, >>) : A << B라고 한다면 A를 좌측으로 B 비트만큼 미는 것이다.**

**🌟 비트 연산의 시간복잡도는 내부적으로 상수 시간 정도로 처리가 되어 O(1)**이라고 보면 된다.

### ✏️ 비트 연산 활용

1. **집합 포함 여부 검사**

0~9까지의 숫자 중 해당 숫자가 현재 집합에 포함되어 있는지를 알아보는 방법이다.

{1, 3, 4, 5, 9} = 570이라고 할 때, 0이 포함된 여부를 검사하려면 0번째 비트만 1로 만들고 나머지를 0으로 한 것과 570을 2진수로 만든 것을 **AND(&) 연산** 하면 있는지를 알 수 있다.

왜냐하면, &연산은 둘 다 1인 경우만 1이므로 0이 포함된 경우는 1로 표시되기 때문에 그 결과로 나온 위치의 비트가 1이라면 해당 수가 집합에 포함 여부를 알 수 있기 때문이다.

570을 이진수로 하면 1000111010 이고 비트가 1인 위치는 1,3,4,5,9 이다.

![Untitled](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/b24a92df-ff98-429b-b6c8-59fd046e8a85)

위의 연산과 같이, 0이 포함되었는지 확인할 수 있는 비트만 1로 놓고 나머지를 0으로 둔 다음 확인을 하면 된다.

## 📕 **백트래킹(Backtracking)**

---

> 백트래킹(backtracking)이란? : 해를 찾는 도중 해가 아니어서 막히면, 되돌아가서 다시 해를 찾아가는 기법을 말합니다. 최적화 문제와 결정 문제를 푸는 방법이 됩니다.
> 

즉, 코딩에서는 반복문의 횟수까지 줄일 수 있으므로 효율적입니다.

이를 **가지치기**라고 하는데, 불필요한 부분을 쳐내고 최대한 올바른 쪽으로 간다는 의미입니다.

일반적으로, 불필요한 경로를 조기에 차단할 수 있게 되어 경우의 수가 줄어들지만, 만약 N!의 경우의 수를 가진 문제에서 최악의 경우에는 여전히 지수함수 시간을 필요로 하므로 처리가 불가능 할 수도 있습니다. **가지치기를 얼마나 잘하느냐에 따라 효율성이 결정되게 됩니다.**

• 주로 문제 풀이에서는 **DFS 등으로 모든 경우의 수를 탐색하는 과정**에서, **조건문 등을 걸어 답이 절대로 될 수 없는 상황을 정의하고, 그러한 상황일 경우에는 탐색을 중지시킨 뒤 그 이전으로 돌아가서 다시 다른 경우를 탐색하게끔** 구현할 수 있습니다.

[](https://www.acmicpc.net/problem/9663)

## 📕 순열 탐색 (Permutation Search)

---

> **‘순열’을 이용하여 모든 경우의 수를 탐색하는 방법이다.** 순열은 서로 다른 n개 중에서 r개를 선택하여 숫자를 모든 순서대로 뽑는 경우를 말한다.
> 

### ✏️ 1. Swap 배열을 이용한 순열

> **배열에서 두 요소의 위치를 바꿔가며 순열을 생성하는 방법이다. 배열의 인덱스 0 부터 순서대로 선택하여 다음 인덱스와 위치를 바꾸고 이를 마지막 인덱스까지 반복한다.**
> 

![Untitled](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/42560fe4-99f6-4e8e-af5f-262d8450f6fb)

### ✏️ 2. Visited 배열을 이용한 순열

> **- 배열에서 '현재 인덱스의 값을 선택한 후' 해당 인덱스를 visited라는 배열에 체크한다. 이후, 다음 인덱스로 넘어가기 전 visited 배열에서 체크되지 않은 가장 작은 인덱스를 선택한다. 이를 마지막 인덱스까지 반복한다.**
> 

![bb](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/268db8e7-d3fd-4033-91e4-93c2b8abaca7)

## 📚 완전 탐색의 시간 복잡도

---

 비트마스크 > DFS/BFS > Brute-Force > 재귀함수 > 순열 > 백트래킹

![bb1](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/2b004b11-8956-4510-b2c6-36c071f0da45)

| 알고리즘 | 시간 복잡도 |
| --- | --- |
| 브루트 포스 | O(nm) |
| 비트마스크 | O(2^n * n) |
| 백트래킹 | 최악의 경우, O(n!) |
| 순열 | O(n!) |
| 재귀함수 | O(n) |
| DFS/BFS | O(V+E) |

## 📕 재귀 함수 (Recursion Function)

---

> **함수 내부에서 ‘자기 자신을 호출’하는 함수를 의미한다.**
> 
> - 이를 통해서 함수가 자신을 반복적으로 호출하면서 원하는 결과를 도출할 수 있다.

 ****

## 📕 **깊이 우선 탐색(DFS: Depth-First Search)**

---

> 루트 노드에서 시작하여 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법을 의미한다.
> 
> - 해당 방식은 자료구조의 ‘스택’을 이용하여서 구현할 수 있다.

### ✏️ 특징

- 자기 자신을 호출하는 **순환 알고리즘**으로 구현할 수 있다.
- 트리 탐색에서 배웠던 전위 탐색(Pre-order) 과 함께 다른 트리 탐색 방법(In-order, Post-order)들도 모두 DFS의 한 종류이다.
- 이후 구현에서 다룰 것이지만 **반드시** 그래프를 탐색하면서 **어떤 노드를 방문했었는지의 여부를 검사**해야한다. (구현에서 visited 변수)
    - 무한루프에 빠질 위험이 있기 때문
- 스택의 구조이기 때문에 **후입선출(LIFO)**의 원칙에 따라 구현된다.

![bb3](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/f80a960b-12ef-4d54-82fe-14978295d523)


### ✏️ 방향 그래프 순환 탐지하기

DFS에서는 **Back Edge가 있으면 순환이 있다**고 본다. Back Edge는 **자기 자신을 가리키거나(self-loop) 자신의 이전 정점(조상 정점)을 가리키는 경우의 Edge(간선)**을 의미한다.

![bb4](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/52fffb81-34e4-4d41-8fbe-95eacf141aef)


여기서 2에서 시작한다고 가정하면 여기서 Back Edge는 1 → 2를 가리키는 것과, 3이 자신을 가리키는 것, 그리고 0이 2를 가리키는 것의 3개가 Back Edge가 된다.

1. 재귀 DFS를 수행할 때, 각 정점의 index와 더불어 방문 여부 배열(visited), 재귀 stack을 전달한다.
2. 현재 정점을 visited 된 것으로 하고 현재 정점을 재귀 stack 에 push한다.
3. 인접 정점 중 방문 되지 않은 정점에 대하여 재귀 호출한다.
4. 만약 현재 방문하고 있는 정점이 재귀 stack에 있다면 cycle이 있는 것으로 간주하여 true를 리턴한다.
5. 자바의 경우 이 전체를 구현하기 위한 wrapper 클래스를 구현하여 cycle 발생 시 true를 리턴하는 식이다.

### 📚참고문헌

[알고리즘 - 그래프 탐색(깊이 우선 탐색 - DFS)](https://hongjw1938.tistory.com/42)

[[Algorithm | Java] 깊이 우선 탐색(DFS) (그래프 탐색) 알고리즘](https://cdragon.tistory.com/entry/Algorithm-깊이-우선-탐색DFS그래프-탐색)

## 📕 **너비 우선 탐색(Breadth-First Search: BFS)**

---

> 루트 노드에서 시작하여 인접한 노드를 먼저 탐색하는 방법을 의미한다.
> 
> - 해당 방식은 **자료구조의 ‘큐’**를 이용하여서 구현할 수 있다.

![bb5](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/6fd1142c-392c-4ed6-93e7-97a66f79f852)


A 정점에서 시작하여 B, C를 우선 탐색하고, 차례대로 B, C가 인접하고 있는 정점을 순환하고 있다. 위의 그림을 통해 순환 되는 순서는 A - B - C - D - E - F - G - H 이다.

### ✏️ 특징

- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.
- 즉, 깊이(deep)탐색하기 전에 넓게(wide) 탐색하는 것이다.
- **사용하는 경우**: 두 노드 사이의 **최단 경로** 혹은 **임의의 경로**를 찾고 싶을 때 이 방법을 선택한다

![bb6](https://github.com/EN-CS-STUDY/CS_STUDY/assets/77156858/76421c97-f996-4861-beec-12fd9ec84fc3)

### ✏️ 구현 방법

**큐(Queue) 자료구조를 통해 구현**된다.

왜? 큐를 사용할까? 큐는 **FIFO(First-In First-Out) 방식**이다. 만약 내가 A 정점을 방문했고 B, C 정점이 인접 정점이라면 B, C를 모두 탐색한 뒤 B, C를 차례로 현재 정점으로 인식하여 다음 정점으로 이동해야 한다.

즉, A정점을 방문 시에, **다음으로 이동할 정점을 큐에 저장하여 First-things-First 라는 Fairness를 구현**하고자 함이다.

### ✏️ BFS를 사용하는 예시

- **최단 경로 문제**

최단 경로 문제는 특히, DFS가 아닌 BFS로 풀어야 문제의 결과를 정확하게 나타낼 수 있다. 왜냐하면, BFS는 모든 정점의 방문 결과를 최단 경로로 보장이 가능하지만 DFS는 보장할 수 없기 때문이다.

하지만 모든 경우에 최단 경로 문제를 BFS로 풀 수 있는 것은 아니다. **BFS로 최단 경로 문제를 해결 가능한 것은 가중치가 1일 때 만이다.** 1이 아니라면 다익스트라 또는 벨만 포드 알고리즘과 같이 응용하여 사용해야 한다.

- 방향 그래프 순환 탐지하기

BFS를 통해 순환을 탐지하기 위해서는 **위상 정렬**을 사용할 수 있습니다.

1. 처음에 내차수(indegree)가 0인 정점을 전부 찾아 각 정점을 큐에 넣는다.
2. 큐에서 하나씩 빼서 방문 완료 처리하고 방문 완료 정점의 수를 1만큼 늘린다.
3. 해당 정점의 인접 정점의 내차수를 1씩 뺀 다음 인접 정점 중에서 내채수가 0이 되는 것만 큐에 넣는다.
4. 큐가 빌 때까지 2, 3번 과정을 반복한다.
5. 큐가 비었는데도 전체 정점의 갯수와 방문 완료한 정점의 갯수가 다르면 해당 그래프에는 Cycle이 있는 것이다.

### 📌 위상정렬

[[Algorithm/Python] 위상 정렬(Topology Sort)란?](https://dmaolon00.tistory.com/entry/AlgorithmPython-위상-정렬Topology-Sort란)

### 📚참고문헌

[알고리즘 - 그래프 탐색(너비 우선 탐색 - BFS)](https://hongjw1938.tistory.com/41)

[[Algorithm | Java] 너비 우선 탐색(BFS)(그래프 탐색) 알고리즘](https://cdragon.tistory.com/entry/Algorithm-너비-우선-탐색BFS그래프-탐색)

### 🤔 DFS vs BFS

| 분류 | 깊이 우선 탐색(DFS) | 너비 우선 탐색(BFS) |
| --- | --- | --- |
| 자료구조 | 스택 | 큐 |
| 탐색방식 | 깊이 우선 | 너비 우선 |
| 모든 경로 탐색 | O | X |
| 최단 경로 탐색 | X | O |
| 재귀 구현 가능 | O | X |
| 반복문 구현 가능 | X | O |
| 메모리 사용량 | 적음 | 많음 |

### 📚 참고문헌

[알고리즘 - 완전탐색(Exhaustive Search)](https://hongjw1938.tistory.com/78)

[[Java/알고리즘] 완전 탐색(Exhaustive Search) 이해하기 -1 : 정의 및 종류](https://adjh54.tistory.com/196)