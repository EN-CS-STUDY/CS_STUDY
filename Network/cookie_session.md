작성자: 신지훈

### connectionless, stateless

쿠키와 세션을 사용하는 이유는 HTTP의 connectionless(비연결성), stateless(비상태성)라는 특징 때문이다. 클라이언트가 요청(request)을 했을 때 그 요청에 맞는 응답(response)을 보낸 후 연결을 끊고, 서버는 클라이언트에 대한 상태 정보를 유지하지 않기 때문에 알 수 없게 된다.

예시로 만약 쿠키와 세션을 사용하지 않는다면 구글에 로그인을 했음에도 페이지를 이동할 때마다 계속 로그인을 해야한다.

또한 로그인을 할때, 아이디 비밀번호 저장을 하여 다음번에 재방문 할 때에도 해당 아이디와 비밀번호를 자동으로 입력하도록 할 수 있다.

이 외에도 쇼핑몰의 장바구니 기능과 팝업에서 “오늘 더이상 이 창을 보지 않음" 등의 편의성을 제공할 수 있게 됩니다

### 1. 쿠키란?

쿠키의 생성과 과정은 구현에따라 다르지만 원리는 동일하다.

1. 서버가 클라이언트로부터 요청을 받았을 때, 클라이언트에 관한 정보를 토대로 쿠키를 구성한다.
2. 서버는 클라이언트에게 보내는 응답의 header에 쿠키를 담아 보낸다.
3. 클라이언트가 응답을 받으면, 브라우저는 쿠키를 쿠키 디렉터리에 저장한다.

쿠키는 클라이언트(브라우저)의 로컬에 key-value쌍이 string 형태로 저장되는 데이터 파일이다.

유효기간 설정이 가능해 유효기간을 설정하면 특정시간동안 쿠키 유지 가능, 그렇지 않다면 브라우저 종료와 함께 소멸된다.

서버에서 response header에 set-cookie속성을 사용해서 클라이언트에 쿠키를 만들고, 사용자가 따로 작업하지 않아도 브라우저가 쿠키를 request header에 담아서 서버에 전송한다.

브라우저가 종료되어도 상태가 유지되고, 클라이언트의 상태정보를 포함하고 있다.

쉽게 말해 **서버는 사용자의 정보를 기억하기 위해 사용자 브라우저의 쿠키라는 공간에 정보를 담는다**고 표현할 수 있다.

자동로그인, 쇼핑카트, 추천, 자동완성과 같은 서비스에서 쿠키가 사용된다.

하지만 사용자 정보가 브라우저에 저장되기 때문에 위변조의 가능성이 높아 보안에 취약하다.

![1](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/f60776c6-1b6b-49c9-8f53-d81b42b48c52)

- 클라이언트가 페이지를 요청
- 서버에서 쿠키를 생성
- HTTP 헤더에 쿠키를 포함시켜 응답
- 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관
- 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 전송
- 서버에서 쿠키를 읽어 이전 상태 정보를 변경할 필요가 있을 때, 쿠키를 업데이트 하여 변경된 쿠키를 HTTP헤더에 포함시켜 응답

### 1-1. 쿠키의 필요성

HTTP프로토콜은 stateless, connectionless특성을 가지고 있다.

이는 요청간에 의존성이 없다는 뜻이고, 매 통신마다 새로 연결해야 한다는 뜻이다.

때문에 현재의 클라이언트가 이전 접속자와 동일한 지 알 수 있는 방법이 없기 때문에 쿠키가 사용된다.

<aside>
💡 **countless**: 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어버리는 특징

</aside>

<aside>
💡 **stateless**: 통신이 끝나면 상태를 유지하지 않는 특징

</aside>

### 2. 세션이란?

세션은 기본적으로 쿠키를 이용하여 구현이 된다. 클라이언트를 구분하기 위해 각 클라이언트에게 session ID를 부여하고 클라이언트는 쿠키에 session ID를 저장해둔다. 사용자 정보를 브라우저에 저장하는 쿠키와 달리 세션은 서버측에 저장해 관리한다.

세션은 유효시간을 두어 일정 시간 응답이 없다면 끊을 수 있고, 브라우저가 종료될 때까지 인증상태를 유지할 수 있다.

사용자 정보를 서버에 두기 때문에 쿠키보다 보안은 좋지만 서버 자원을 차지하기 때문에 서버에 과부하를 줄 수 있고, 성능 저하의 요인이 될 수 있다..

정리하자면 서버에 정보를 저장하기 때문에 **쿠키보다 보안성이 높다. 하지만 사용자가 많아질수록 서버 메모리를 많이 차지**하게 된다.

즉, 동접자 수가 많은 웹사이트인 경우, 서버에 과부하를 주게 되므로 성능 저하의 요인이 된다.

클라이언트가 요청을 보내면 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는데 이것이 세션 ID이다.

로그인 같이 보안상 중요한 작업을 할 때 주로 사용한다.

![2](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/92485267-3254-434d-a859-263f418be639)

### 2-1. 세션의 동작방식

- 클라이언트가 서버에 접속 시 세션 ID발급 받음
- 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장
- 서버에 요청할 때, 쿠키의 세션ID를 같이 서버에 전달해서 요청
- 서버는 세션 ID를 전달 받아 별도의 작업없이 세션 ID로 세션에 있는 클라이언트 정보를 가져와서 사용
- 클라이언트 정보를 가지고 서버 요청을 처리해 클라이언트에게 응답

### Q. 쿠키의 사용 예시

1. 쇼핑몰의 장바구니 기능
2. 로그인 시 아이디와 비밀번호 저장(자동 로그인)
3. 팝업에서 “오늘 더이상 이 창을 보지 않음” 체

### Q. 쿠키와 세션의 차이

쿠키는 클라이언트 로컬에 key-value쌍으로 저장되는 데이터 파일이다. 유효시간 내에서는 브라우저가 종료되어도 계속 유지된다.

세션은 브라우저가 종료되거나, 서버에서 해당 세션을 삭제할 수 있기 때문에 쿠키보다 보안성이 좋다. 또한 서버에 데이터를 저장하므로 서버 용량이 허용하는 한에서 제한 없이 데이터를 저장할 수 있다는 장점이 있다.

하지만 서버의 부하가 커진다는 단점이 있다.

### Q. 세션이 보안도 좋은데 왜 쿠키를 사용하는가?

세션은 서버의 자원을 사용하기 때문에 서버가 느려질 수 있고, 서버 자원이 부족할 수 있다. 따라서 쿠키를 사용하면 서버 자원의 낭비를 방지해 웹사이트 속도를 높일 수 있다.

---

### 쿠키와 세션을 이용한 로그인 동작 방식

![3](https://github.com/EN-CS-STUDY/CS_STUDY/assets/81848426/2212d32c-6568-4edc-929d-ba7a10ca3a93)

### 쿠키와 세션을 통한 인증(authentication)과 인가(authorization)

인증(authentication)은 사용자가 누구인지 확인하는 절차다. 회원가입과 로그인 과정이 인증의 대표적인 예시이다.

인가(authorization)는 사용자가 요청하는 것에 대한 권한이 있는지를 확인하는 절차다.

세션을 통한 인증, 인가(auth)의 절차는 다음과 같다.

1. 클라이언트가 로그인을 하면 서버는 회원정보를 대조하여 인증(authentication)
2. 회원 정보(클라이언트 정보)를 세션저장소에 생성하고 session ID를 발급
3. http response header 쿠키에 발급한 session ID를 담아서 전송
4. 클라이언트에서는 session ID를 쿠키 저장소에 저장하고 이후에 http request를 보낼 때마다 쿠키에 session ID를 담아서 전송
5. 서버에서는 쿠키에 담겨져서 온 session ID에 해당하는 회원 정보를 세션 저장소에서 가져옴(authorization)
6. 응답 메시지에 회원 정보를 바탕으로 처리된 데이터를 담아서 클라이언트에 전송

사용자가 로그인을 하면 서버는 session ID를 쿠키로 클라이언트에게 보낸다. 클라이언트는 session ID를 요청시마다 헤더에 담아서 보내면 서버는 session ID에 해당하는 클라이언트 정보를 세션저장소에서 가져온다. 이를 통해 클라이언트 정보에 따라 맞춤 응답을 할 수 있게 된다. 하지만 서버에서 세션저장소를 사용하여 사용자 데이터를 저장해야 되기 때문에 추가적인 저장공간을 필요로 한다.

session ID만 쿠키에 담겨서 요청을 보내기 때문에 요청 때마다 사용자 정보를 쿠키에 담아서 전송하는 것보다 안전하다. 하지만 session ID만 노출되어 악의를 가진 다른 사용자가 이를 이용해 서버에 요청하면 서버는 구별해낼 수 있는 방법이 없다. 이를 Session hijacking 이라고 한다. 해결책으로는 HTTPS 를 사용하거나 session에 짧은 주기로 만료시간을 설정하는 방법이 있다.

또한 세션과 쿠키를 이용한 로그인 방식은 Load Balancing 및 서버 효율성 관리 및 확장이 어려워질 수 있다는 단점이 있다.
