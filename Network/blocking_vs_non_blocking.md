### 작성자 : 박민지
<br>

# Blocking and Non-Blocking

### Q. I/O작업이란?
> I/O작업은 `Kernel level`에서만 수행된다.<br>
> 유저 프로세스(스레드)는 커널에게 I/O작업을 요청한다<br>
> **작업 완료 후 커널이 반환하는 결과를 기다릴 뿐이다**<br>
>
> *I/O는 **어플리케이션 성능에 가장 많은 영향**을 끼친다<br>
> *network에서의 I/O작업 == 소켓의 read/send

##### *I/O와 성능
- **I/O의 발생 시간 == CPU 대기 시간**
- I/O가 많아진다는 것은 어플리케이션이 연산할때까지 CPU의 대기시간이 길어진다
- 어떤 함수든 일정시간동안 CPU를 잡아두고 사용하기 때문에 다음 작업 실행을 block한다
- I/O로 인한 blocking 시간 동안 **CPU는 다른 작업을 할 수 있어도 하지 못하는 비효율**적인 시간이다

<br>

### Q. Blocking이란?
<img width="600" alt="image" src="https://github.com/EN-CS-STUDY/CS_STUDY/assets/100523178/d7cb82ae-2442-4c41-a349-4186d88e6519">

`" I/O작업이 진행되는 동안 유저 프로세스가 자신의 작업을 중단한 채 대기하는 방식 "`
- 가장 기본적인 I/O모델
- 리눅스에서 모든 소켓 통신은 기본적으로 blocking으로 동작한다

1. 유저가 Kernel에 read작업을 요청한다
2. 데이터가 입력될때까지 대기한다 (프로그램의 실행을 멈춤)
3. 데이터가 입력되면 유저에게 결과가 전달되어야만 유저의 작업에 복귀할 수 있다

###### *block이 된 후 어플리케이션에서 다른 작업을 수행하지 못하고 대기하기 때문에 자원이 낭비된다
###### *I/O작업의 지연으로 인해 전체 프로그램 성능이 저하될 수 있다
<br>

### Q. Non-Blocking이란?
<img width="600" alt="image" src="https://github.com/EN-CS-STUDY/CS_STUDY/assets/100523178/592c050e-5691-4eaa-a1ab-dec87581e37a">

`" I/O작업이 진행되는 동안 유저 프로세스의 작업을 중단시키지 않는 방식 "`
- blocking 방식의 비효율성을 극복하기 위해 도입된 방식
- **I/O작업 요청 후 바로 제어권을 반환**하여 작업의 완료 여부와 상관없이 다음 작업을 계속 진행한다
- I/O작업이 진행되는 동안 다른 작업을 병렬로 처리하여 프로그래밍 성능을 향상할 수 있다

1. 유저가 kernel에 read작업을 요청한다
2. 데이터의 입력 유무와 상관없이 요청 즉시 결과가 바로 반환된다
   (입력 데이터가 없는 경우 입력 데이터가 없다는 결과 메세지 반환)
3. 입력 데이터가 있을 때까지 1~2번을 반복한다
4. 입력 데이터가 있으면 유저에게 결과가 전달된다

###### *I/O의 진행시간과 관계가 없기 때문에 대기 시간이 없다
###### *어플리케이션에서 작업을 오랜시간 중지하지 않아도 I/O작업이 가능하다
###### *반복적으로 시스템 호출이 발생하기 때문에 자원이 낭비된다

### Q. Blocking과 Non-Bloking





**Blocking/Non-Blocking, Sync/Asyc는 같은 개념일까?**
> 두 개념은 표현 형태는 비슷해 보이지만, 서로 다른 차원에서 작업의 수행 방식을 설명한다<br>
> `동기/비동기`
> - 요청 작업에 대한 완료 여부가 중요하다
> - 작업을 순차적으로 진행할지 아닌지에 대한 관점이다
> `블로킹/논블로킹`
> - 현재 작업의 block 여부에 따라 다른 작업을 수행할 수 있는지에 대한 관점이다
> 

### Q. 자바에서의 블로킹과 논블로킹 I/O
> 자

