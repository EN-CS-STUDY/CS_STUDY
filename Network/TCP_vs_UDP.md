### TCP
---
#### Transmission Control Protocol (전송 제어 프로토콜)
- 애플리케이션 사이에서 안전하게 데이터를 통신하는 규약
- 4번째 계층인 전송 계층(Transport Layer)에서 사용
- `연결 지향 프로토콜`이기 때문에 TCP는 통신을 수행하기 전, 먼저 두 컴퓨터 간에 세션이 존재하는지 확인해야 함
<br>

### TCP HandShake
---
#### TCP 에서 연결 설정(connection establishment)은 `3-way handshake`를 통해 이루어진다
- 데이터의 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다
- 양쪽 모두 데이터 전송 준비가 완료되었음을 보장한다
- 총 3 단계로 이루어진다
  - connection setup (3-way handshake)
  - data transfer
  - connection termination (4-way-handshake)
- TCP 통신은 `양방향성 연결`이기 때문에 클라이언트의 요청, 서버의 허가, 클라이언트의 응답 과정까지 총 3번의 handshaking 과정이 필요하다
<br>

#### [1 단계] 3-way handshake를 통해 동기화를 진행한다
<img width="500" alt="image" src="https://github.com/EN-CS-STUDY/CS_STUDY/assets/100523178/a826a5dd-a3be-4192-9373-c4afccdddecb">

> 1. Client > Server : TCP SYN<br>
>    (연결 요청) 클라이언트가 서버에게 SYN 패킷을 보냄 (sequence)
> 2. Server > Client : TCP SYN ACK<br>
>    (연결 허가) 서버가 SYN-ACK(sequence + 1)로 응답
> 3. Client > Server : TCP ACK<br>
>    (허가 응답) 클라이언트가 서버에게 ACK(squence + 1)를 보내면 연결이 이루어짐
>
>    ###### *SEQ: 송신 측에서 데이터를 세그먼트로 나눌 때 각 세그먼트의 시작 위치를 식별하기 위해 사용 (ACK)
>    ###### *ACK: 송신 측으로부터 받은 데이터의 바로 다음에 기대되는 데이터의 순서 번호
<br>

#### [2 단계] 데이터 통신
#### 네트워크에서는 데이터를 통신할 때 여러 조각으로 나누어 각 조각을 따로 전달한 뒤 합친다
> 1. 데이터 스트림에서 받은 데이터를 일정 단위로 분할한다
> 2. 분할된 데이터 단위에 TCP 헤더를 붙여서 `TCP 세그먼트`를 생성한다
> 3. TCP 세그먼트를 `IP 데이터그램`으로 변환한다
> 4. IP 데이터그램을 수신 애플리케이션에 보낸다
>    
>    ###### *TCP segment(TCP header + data): 데이터 전송 단위, 수신 애플리케이션에서 데이터를 안전하고 정확하게 원상복구하도록 함
>    ###### *IP datagram: 인터넷 통신에 사용되는 데이터 패킷
<br>

#### [3 단계] 4-way-handshake
- 안전하게 통신을 종료한다
<br>

### 신뢰성을 보장하는 방법
---
#### 1. 흐름 제어 (Flow Control)
- `데이터 양을 조절한다`
- 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법
  - 수신측의 처리 능력을 초과하지 않도록 보장
- " receiver가 sender에게 현재 자신의 상태를 feedback 한다 "
  - 수신측은 자신의 버퍼 용량, 처리 속도를 송신측에 알려주어 송신측에서 데이터를 보내는 속도를 조절
  - overflow 상황에서 발생하는 데이터 손실을 방지하고 안정적인 연결을 수립

#### [Stop and Wait]
#### 매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷을 전송할 수 있다
<img width="300" src="https://github.com/EN-CS-STUDY/CS_STUDY/assets/100523178/5a0518ea-3f44-4ef6-91f0-b549029615a9"/>

- 장점
  - 구현이 간단하고 오류 검출 및 복구가 쉽다
- 단점
  - 매번 한개의 세그먼트만 전송 가능하다 (전송 효율↓)
  - 중간에 신호가 유실되거나 데이터 전송이 지연되어서 time-out이 발생하게 되면 손실된 세그먼트를 재전송 해야 한다 (중복된 프레임 발생)

#### [Sliding Window]
#### 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절한다
<img width="300" src="https://github.com/EN-CS-STUDY/CS_STUDY/assets/100523178/5c6c6ece-f202-4f15-bfdd-306e9e98b62a"/>

- 슬라이딩 윈도우 수행 과정
  - 1번에 대한 ACK가 수신측으로 부터 송신측에 전달되면서 2,3에 대한 ACK만 기다리면서 자리 하나가 남게 된다 (window-size = 3)
  - 자리가 하나가 남아 다음 프레임인 4를 전달할 수 있게 된다
- 장점
  - 송신측에서는 ACK 프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송할 수 있다 
<br>

#### 2. 혼잡 제어 (Congestion Control )
- `데이터 유실, 잘못된 데이터 수신을 대처한다`
- 처리 속도보다 많은 양의 데이터를 너무 빠르게 전송하여 발생하는 네트워크 혼잡 현상
- 한 라우터에 데이터가 몰릴 경우 데이터를 모두 처리할 수 없게 되고 오버플로우로 데이터 손실이 발생할 수 있기 때문에 `데이터 전송 속도를 강제로 줄임`

#### [Fast Retransmit]
<img width="300" src="https://github.com/EN-CS-STUDY/CS_STUDY/assets/100523178/0c055b3b-a9ed-48db-8d39-4aab3af68aa1"/>

> 1. 수신자에게 세그먼트로 분할된 내용들이 순서대로 도착하지 않은 경우, 순서대로(정상적으로) 마지막에 도착한 패킷의 다음 패킷 순번을 ACK에 보낸다
> 2. 중간에 패킷 하나가 손실되면 송신측에서는 순번이 중복된 ACK 패킷을 받게 된다
> 3. 2번이 `3번 중복되면 오류가 난 패킷을 재전송`하게 된다

- 장점
  - 설정한 time out이 지나지 않아도 `3번의 중복된 ACK패킷을 받게되면 해당 패킷을 바로 재전송` 할 수 있다 (`빠른 재전송`)
  - `패킷의 순서를 유지`해 보다 신뢰성있는 데이터 송수신을 할 수 있다


#### 3. 오류 제어
- `네트워크 혼잡에 대처한다`
- (수신자) 훼손된 패킷, 중복 수신된 패킷 확인 후 폐기
- (수신자) 분실된 패킷이 도착할때까지 순서에 맞지 않는 세그먼트를 버퍼에 저장
- (송신자) 훼손되거나 손실된 패킷은 재전송을 통해 오류 복구

> - 검사합(Check Sum): 세그먼트내에 있는 검사합 필드를 통해 패킷이 훼손되었는지 확인한다.
> - 확인응답(Acknowledgement): 세그먼트의 수신을 알려주기 위해 확인 응답을 사용한다.
> - 타임아웃(Time-out): 송신 TCP는 연결당 재전송 타임아웃(RTO, retransmission time-out) 타이머를 사용하여 패킷의 재전송 시기 결정
